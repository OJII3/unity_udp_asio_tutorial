# Chapter 9 - システム構成

## AppState

アプリの状態を定義したenumクラス。今回は、接続と切断しか状態がなかった。

## AppManager

Manager と言っているが、実際にはステートを持ち、ステートの変化に応じてイベントを発行するだけのクラス。IAppManager インターフェースを実装しており、IAppManager へDIすることで、AppManager が持つステートを外部から参照、変更することができる。多くのクラスが AppManager を参照しているが、AppManager は他のクラスを参照していない。AppManager は、ステートの変化に応じて、イベントを発行するだけのクラスである。

## Ros2Uity

Kottaku さんの Android ビルド対応版と格闘したなごり。結果として一切使用していない。

## Timer

R3 を用いて実装した、ただのタイマー。コンストラクターでタイマーの頻度と、タイマーのイベントを登録する。`StartTimer` メソッドでタイマーを開始し、`StopTimer` メソッドでタイマーを停止する。`Tick` イベントが発生するたびに、登録されたイベントが呼び出される。

UDPクライアントの`ReceiveAsync` メソッドの中断の都合もあるのか、ただしく`Cancellation` できていない気もする...

## Node

- `Receiver.cs` と`Joycon.cs` がほぼほぼ本体。
- `Joycon.cs`: 今回は送る内容がジョイコンのボタンだけだったため、`Sender`クラスが存在しない. UDP通信には`System.Net.Sockets` を使用しているため、追加ライブラリ等は必要ない。ただし、Unity の .Net は Unity 仕様であるため、Microsoft 等のドキュメントと多少異なる部分があるので注意。また、ブロードキャストは事前に有効化する必要がある他、接続中のインターフェースのIPとそのサブネットマスクを意識してブロードキャストアドレスを指定しないと正しくブロードキャストできないので注意。
- `Receiver.cs`: 送られてきたデータをプロトコルに従って解釈し、特にタイプに応じて各クラスにデータを渡す。今回はオドメトリのデータとシーケンスのデータだけだった。本来、スリーウェイハンドシェイク的な処理を行ない、メインの通信はUDPのユニキャストで行う予定だったが、切断・再接続の処理で行きづまったため、全ての通信を一旦ブロードキャストで実装した。通信確立の際、`ConnectionCheck` タイプのパケットを受信するはずであった。
- 接続状態を変えるのは`ConnectionChecker` クラスのみである。コントローラー、ロボット共に常時データを送信しつづけているはずで、タイマーで受信頻度を監視している。(あくまで受信成功しか意味していない上、実際のデータ転送に使うポートは使用しないが、高確率で通信の確立の判断に使える...)
- 各種ハンドラークラスは、`Receiver` から呼びだされると対応したUIの更新などの処理を行う。
- Node というフォルダ名は ROS 2 の様な構成にしようとしたなごり。特にNodeというベースクラスがあるわけでもなければ、その機能もない。ただのROS2 側のクラスと似た機能をもつクラスである.

## UI Manager

カスのクラス。ゴミ。

## GamePad

InputActions と Joycon クラスの橋渡しをするクラス。初期に適当に生やしてしまったため、あまり正しく役割を果たしていない。

## ConfigLoader

Android 上で正しく機能しているか怪しい。いずれドメインIDの保存に対応したり、現状では使用するLANの選択ができるようになっている。
